<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Simulation d‚Äô√©volution ‚Äì Damier & multiples cellules</title>
<style>
  :root {
    --bg: #0f1220;
    --panel: #161a2b;
    --text: #e8ecff;
    --muted: #a6add9;
    --accent: #7aa2ff;
    --accent2: #6ee7b7;
    --gridA: #1b2239;
    --gridB: #12172a;
    --plant: #39d353;      /* vert */
    --herb:  #ffe66d;      /* jaune */
    --carn:  #ff6b6b;      /* rouge */
    --wall:  #7c859e;      /* gris */
  }
  html, body { height: 100%; background: radial-gradient(1200px 800px at 70% -10%, #1b2350 0%, #0f1220 40%, #0b0d18 100%); margin: 0; color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Ubuntu, Cantarell, Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; }
  .wrap { display: grid; grid-template-columns: 1fr 360px; gap: 16px; height: 100%; padding: 16px; box-sizing: border-box; }
  @media (max-width: 980px) { .wrap { grid-template-columns: 1fr; grid-auto-rows: min-content; } }
  #canvas { width: 100%; height: 100%; background: #0b0e1a; border-radius: 10px; box-shadow: 0 12px 40px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.06); }
  .panel { background: rgba(20,25,45,.7); backdrop-filter: blur(6px); border: 1px solid rgba(255,255,255,.06); border-radius: 12px; padding: 14px; box-shadow: 0 12px 32px rgba(0,0,0,.25); }
  h1 { font-size: 18px; margin: 0 0 8px; font-weight: 700; letter-spacing:.2px }
  .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin: 8px 0; }
  .row3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin: 8px 0; }
  button, select, input[type="number"], input[type="range"] {
    background: #0f1327; color: var(--text); border: 1px solid rgba(255,255,255,.1);
    padding: 10px 12px; border-radius: 10px; font-weight: 600; cursor: pointer; width: 100%;
  }
  button:hover { border-color: rgba(255,255,255,.22); }
  .badges { display:flex; gap:8px; flex-wrap:wrap; margin:8px 0 4px; }
  .badge { display:inline-flex; align-items:center; gap:8px; padding:8px 10px; border-radius:10px; font-weight:700; border:1px solid rgba(255,255,255,.08); background:#0f1327; white-space:nowrap; }
  .dot { width:14px; height:14px; border-radius:3px; display:inline-block; }
  .plant{ background:var(--plant); } .herb{ background:var(--herb); } .carn{ background:var(--carn); } .wall{ background:var(--wall); } .empty{ background:linear-gradient(135deg,var(--gridA),var(--gridB)); }
  label { font-size: 12px; color: var(--muted); display:block; margin: 6px 0 6px; }
  .small { font-size: 12px; color: var(--muted); }
  .footer { opacity:.7; font-size:12px; margin-top:8px }
  .sep { height:1px; background: linear-gradient(90deg, transparent, rgba(255,255,255,.1), transparent); margin:12px 0; }
</style>
</head>
<body>
<div class="wrap">
  <canvas id="canvas"></canvas>
  <div class="panel">
    <h1>Simulation d‚Äô√©volution</h1>
    <div class="badges">
      <span class="badge"><span class="dot empty"></span>Damier</span>
      <span class="badge"><span class="dot plant"></span>Plante</span>
      <span class="badge"><span class="dot herb"></span>Herbivore</span>
      <span class="badge"><span class="dot carn"></span>Carnivore</span>
      <span class="badge"><span class="dot wall"></span>Mur</span>
    </div>

    <label>Outil de peinture</label>
    <div class="row">
      <select id="brush">
        <option value="0">Vide (gomme)</option>
        <option value="4">Mur</option>
        <option value="1" selected>Plante</option>
        <option value="2">Herbivore</option>
        <option value="3">Carnivore</option>
      </select>
      <select id="paintMode">
        <option value="single">Peindre au clic</option>
        <option value="drag" selected>Peindre en glissant</option>
        <option value="rect">Rectangles</option>
      </select>
    </div>

    <label>Contr√¥les</label>
    <div class="row3">
      <button id="toggle">‚ñ∂Ô∏é Lancer</button>
      <button id="step">‚è≠Ô∏è Step</button>
      <button id="reset">‚ôªÔ∏è R√©initialiser</button>
    </div>
    <div class="row3">
      <button id="randomPlants">üå± Seed plantes</button>
      <button id="randomHerb">üê≠ Seed herb.</button>
      <button id="randomCarn">ü¶ä Seed carn.</button>
    </div>

    <div class="sep"></div>

    <label>Vitesse (ms/tour)</label>
    <input type="range" id="speed" min="10" max="400" value="80" />
    <label>Taille de la grille (c√¥t√©s)</label>
    <div class="row">
      <input type="number" id="cols" min="10" max="200" step="1" value="80" />
      <input type="number" id="rows" min="10" max="200" step="1" value="50" />
    </div>
    <button id="applySize">üìê Appliquer la taille</button>

    <div class="sep"></div>

    <label>Param√®tres (√©volution)</label>
    <div class="row">
      <input type="number" id="plantSpread" value="0.045" step="0.005" />
      <input type="number" id="plantDecay" value="0.000" step="0.001" />
    </div>
    <div class="small">Plante: proba pousse par case vide voisine / proba de fl√©trir par tour.</div>

    <div class="row">
      <input type="number" id="herbEat" value="8" step="1" />
      <input type="number" id="herbMoveCost" value="1" step="1" />
    </div>
    <div class="small">Herbivore: √©nergie gagn√©e en mangeant / co√ªt d√©placement.</div>

    <div class="row">
      <input type="number" id="carnEat" value="14" step="1" />
      <input type="number" id="carnMoveCost" value="1" step="1" />
    </div>
    <div class="small">Carnivore: √©nergie gagn√©e en chassant / co√ªt d√©placement.</div>

    <div class="row">
      <input type="number" id="reproEnergy" value="18" step="1" />
      <input type="number" id="maxAge" value="600" step="10" />
    </div>
    <div class="small">Reproduction (se divise si √©nergie ‚â• seuil) / √Çge max (tours).</div>

    <div class="sep"></div>

    <div class="row">
      <button id="export">üíæ Exporter √©tat</button>
      <button id="import">üì• Importer √©tat</button>
    </div>
    <textarea id="io" rows="4" style="width:100%;margin-top:8px;background:#0f1327;color:var(--text);border:1px solid rgba(255,255,255,.1);border-radius:10px;padding:8px;" placeholder="√âtat en JSON‚Ä¶"></textarea>

    <div class="footer">
      Astuces : peignez des <b>plantes</b> puis quelques <b>herbivores</b> et <b>carnivores</b>, lancez la sim, ajustez la vitesse et les co√ªts. Les bords sont en <i>torus</i> (le monde boucle).
    </div>
  </div>
</div>

<script>
/* =======================
   Simulation d‚Äô√©volution
   Grille en damier + types de cellules : Vide, Mur, Plante, Herbivore, Carnivore
   R√®gles (r√©sum√©) :
   - Plantes : peuvent pousser dans les cases vides adjacentes (probabilit√©), et fl√©trir (faible proba).
   - Herbivores : perdent de l‚Äô√©nergie √† chaque pas, cherchent/mangent des plantes (+√©nergie), se reproduisent si √©nergie √©lev√©e, meurent si √©nergie 0 ou √¢ge max.
   - Carnivores : similaire, mais chassent les herbivores.
   - Mouvements sur 8 voisins. Monde torique (wrap).
   ======================= */

const T = { EMPTY:0, PLANT:1, HERB:2, CARN:3, WALL:4 };

const colors = {
  [T.EMPTY]: null, // damier dessin√© s√©par√©ment
  [T.PLANT]: getCss('--plant'),
  [T.HERB]:  getCss('--herb'),
  [T.CARN]:  getCss('--carn'),
  [T.WALL]:  getCss('--wall'),
};

function getCss(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha:false });

let COLS = +document.getElementById('cols').value;
let ROWS = +document.getElementById('rows').value;

let grid, energy, age;

function make2D(cols, rows, fill=0){
  const a = new Array(rows);
  for(let y=0;y<rows;y++){
    a[y] = new Array(cols).fill(fill);
  }
  return a;
}

function resizeCanvas(){
  // remplir tout l'espace de gauche
  const left = document.querySelector('.wrap').getBoundingClientRect();
  const panel = document.querySelector('.panel').getBoundingClientRect();
  const isNarrow = window.innerWidth <= 980;
  const w = isNarrow ? left.width - 32 : left.width - panel.width - 24;
  const h = left.height - 32;
  canvas.width = Math.max(200, Math.floor(w));
  canvas.height = Math.max(200, Math.floor(h));
}

window.addEventListener('resize', ()=>{ resizeCanvas(); draw(); });

function init(){
  grid = make2D(COLS, ROWS, T.EMPTY);
  energy = make2D(COLS, ROWS, 0);
  age = make2D(COLS, ROWS, 0);
}

function wrap(x, max){ return (x + max) % max; }

const NBR = [
  [-1,-1],[0,-1],[1,-1],
  [-1, 0],       [1, 0],
  [-1, 1],[0, 1],[1, 1]
];

function neighbors(x, y){
  const list = [];
  for(const [dx,dy] of NBR){
    const nx = wrap(x+dx, COLS);
    const ny = wrap(y+dy, ROWS);
    list.push([nx,ny]);
  }
  return list;
}

function step(){
  // param√®tres dynamiques (depuis l‚ÄôUI)
  const plantSpread = parseFloat(document.getElementById('plantSpread').value);
  const plantDecay  = parseFloat(document.getElementById('plantDecay').value);
  const herbEat     = parseInt(document.getElementById('herbEat').value);
  const herbMoveCost= parseInt(document.getElementById('herbMoveCost').value);
  const carnEat     = parseInt(document.getElementById('carnEat').value);
  const carnMoveCost= parseInt(document.getElementById('carnMoveCost').value);
  const reproEnergy = parseInt(document.getElementById('reproEnergy').value);
  const maxAge      = parseInt(document.getElementById('maxAge').value);

  const next = make2D(COLS, ROWS, T.EMPTY);
  const nEnergy = make2D(COLS, ROWS, 0);
  const nAge = make2D(COLS, ROWS, 0);

  // 1) Les murs restent en place
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      if(grid[y][x] === T.WALL){
        next[y][x] = T.WALL;
      }
    }
  }

  // 2) Plantes : poussent/ persistent / fl√©trissent
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      if(next[y][x] === T.WALL) continue;
      const cell = grid[y][x];
      if(cell === T.PLANT){
        // peut fl√©trir
        if(Math.random() < plantDecay){
          // devient vide
        }else{
          next[y][x] = T.PLANT;
        }
      }else if(cell === T.EMPTY){
        // pousse si voisine plante
        const neigh = neighbors(x,y);
        let hasPlant = false;
        for(const [nx,ny] of neigh){
          if(grid[ny][nx] === T.PLANT){ hasPlant = true; break; }
        }
        if(hasPlant && Math.random() < plantSpread){
          next[y][x] = T.PLANT;
        }
      }
    }
  }

  // Helpers pour d√©placer une entit√©
  function tryMoveEntity(x, y, type, moveCost, eatType, eatGain){
    // Chercher d'abord une cible (plante pour herbivore, herbivore pour carnivore)
    let target = null;
    for(const [nx,ny] of neighbors(x,y)){
      if(grid[ny][nx] === eatType){ target = [nx,ny]; break; }
    }
    // Sinon mouvement "greedy" vers la densit√© de cibles proche (regard 2 cases)
    function scoreCell(cx, cy){
      let s = 0;
      for(const [dx,dy] of NBR){
        const ax = wrap(cx+dx, COLS);
        const ay = wrap(cy+dy, ROWS);
        if(grid[ay][ax] === eatType) s += 1;
      }
      return s;
    }

    let dest = null, ate = false;
    if(target){
      dest = target; ate = true;
    }else{
      // candidates vides (ou plantes si herbivore)
      const cands = [];
      for(const [nx,ny] of neighbors(x,y)){
        if(next[ny][nx] === T.EMPTY && grid[ny][nx] !== T.WALL){
          cands.push([nx,ny]);
        }
      }
      if(cands.length){
        // pr√©f√©rer les cases o√π il y a plus de proies autour
        let best = cands[0], bestS = -1;
        for(const c of cands){
          const s = scoreCell(c[0], c[1]);
          if(s > bestS){ best = c; bestS = s; }
        }
        dest = best;
      }
    }

    // statut √©nergie/√¢ge
    let e = (energy[y][x] || 0) - moveCost;
    let a = (age[y][x] || 0) + 1;

    if(dest){
      const [dx,dy] = dest;
      // si on atterrit sur une proie (dans le cas herb -> plante possible si la plante n‚Äôa pas encore √©t√© pos√©e)
      if(grid[dy][dx] === eatType || next[dy][dx] === eatType){
        ate = true;
      }
      // d√©poser l‚Äôentit√© si la case est libre √† "next"
      if(next[dy][dx] === T.EMPTY){
        next[dy][dx] = type;
        nAge[dy][dx] = a;
        nEnergy[dy][dx] = e + (ate ? eatGain : 0);
      }else{
        // collision : rester sur place si possible
        if(next[y][x] === T.EMPTY){
          next[y][x] = type;
          nAge[y][x] = a;
          nEnergy[y][x] = e; // (pas mang√©)
        }
      }
    }else{
      // ne bouge pas
      if(next[y][x] === T.EMPTY){
        next[y][x] = type;
        nAge[y][x] = a;
        nEnergy[y][x] = e;
      }
    }
  }

  // 3) Faune : herbivores puis carnivores, sur l‚Äô√©tat "grid" d‚Äôorigine, en √©crivant dans "next"
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      if(grid[y][x] === T.HERB){
        tryMoveEntity(x,y,T.HERB,herbMoveCost,T.PLANT,herbEat);
      }
    }
  }
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      if(grid[y][x] === T.CARN){
        tryMoveEntity(x,y,T.CARN,carnMoveCost,T.HERB,carnEat);
      }
    }
  }

  // 4) Repro / Mort par √©nergie/√¢ge
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const t = next[y][x];
      if(t === T.HERB || t === T.CARN){
        const e = nEnergy[y][x];
        const a = nAge[y][x];
        if(e <= 0 || a > maxAge){
          next[y][x] = T.EMPTY;
          nEnergy[y][x] = 0;
          nAge[y][x] = 0;
        }else if(e >= reproEnergy){
          // tenter de se diviser dans une case voisine libre
          const emptyNbr = neighbors(x,y).filter(([nx,ny])=> next[ny][nx] === T.EMPTY);
          if(emptyNbr.length){
            const [cx,cy] = emptyNbr[Math.floor(Math.random()*emptyNbr.length)];
            next[cy][cx] = t;
            // partage d‚Äô√©nergie et √¢ge reset pour l‚Äôenfant
            const childE = Math.floor(e/2);
            nEnergy[cy][cx] = childE;
            nAge[cy][cx] = 0;
            nEnergy[y][x] = e - childE;
          }
        }
      }
    }
  }

  grid = next;
  energy = nEnergy;
  age = nAge;
}

function draw(){
  const w = canvas.width, h = canvas.height;
  ctx.fillStyle = getCss('--gridB');
  ctx.fillRect(0,0,w,h);

  const cellW = Math.floor(w / COLS);
  const cellH = Math.floor(h / ROWS);
  const cw = Math.max(3, cellW), ch = Math.max(3, cellH);

  // damier
  const A = getCss('--gridA');
  const B = getCss('--gridB');
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      ctx.fillStyle = ((x+y)&1) ? A : B;
      ctx.fillRect(x*cw, y*ch, cw, ch);
    }
  }

  // cellules
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const t = grid[y][x];
      if(t !== T.EMPTY){
        ctx.fillStyle = colors[t];
        ctx.fillRect(x*cw+1, y*ch+1, cw-2, ch-2);
      }
    }
  }
}

let timer = null;
function loop(){
  step();
  draw();
}

document.getElementById('toggle').addEventListener('click', e=>{
  if(timer){
    clearInterval(timer); timer = null;
    e.target.textContent = '‚ñ∂Ô∏é Lancer';
  }else{
    const speed = +document.getElementById('speed').value;
    timer = setInterval(loop, speed);
    e.target.textContent = '‚è∏Ô∏é Pause';
  }
});

document.getElementById('speed').addEventListener('input', e=>{
  if(timer){
    clearInterval(timer);
    timer = setInterval(loop, +e.target.value);
  }
});

document.getElementById('step').addEventListener('click', ()=>{
  if(timer) return;
  loop();
});

document.getElementById('reset').addEventListener('click', ()=>{
  init(); draw();
});

document.getElementById('applySize').addEventListener('click', ()=>{
  COLS = clamp(+document.getElementById('cols').value, 10, 200);
  ROWS = clamp(+document.getElementById('rows').value, 10, 200);
  init(); resizeCanvas(); draw();
});

function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

// Seed helpers
function randomSeed(type, density){
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      if(grid[y][x] !== T.EMPTY) continue;
      if(Math.random() < density){ grid[y][x] = type; }
    }
  }
  draw();
}
document.getElementById('randomPlants').addEventListener('click', ()=> randomSeed(T.PLANT, 0.10));
document.getElementById('randomHerb').addEventListener('click', ()=> randomSeed(T.HERB, 0.02));
document.getElementById('randomCarn').addEventListener('click', ()=> randomSeed(T.CARN, 0.01));

// Peinture
const brush = document.getElementById('brush');
const paintMode = document.getElementById('paintMode');
let painting = false;
let startCell = null;

function canvasToCell(clientX, clientY){
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor((clientX - rect.left) / (canvas.width / COLS));
  const y = Math.floor((clientY - rect.top) / (canvas.height / ROWS));
  return [clamp(x,0,COLS-1), clamp(y,0,ROWS-1)];
}
function setCell(x,y,t){
  grid[y][x] = t;
  energy[y][x] = 0; age[y][x] = 0;
}
canvas.addEventListener('pointerdown', e=>{
  painting = true;
  const [x,y] = canvasToCell(e.clientX, e.clientY);
  startCell = [x,y];
  if(paintMode.value === 'rect'){
    // attendre pointerup pour dessiner le rectangle
  }else{
    setCell(x,y, +brush.value);
    draw();
  }
});
canvas.addEventListener('pointermove', e=>{
  if(!painting) return;
  const [x,y] = canvasToCell(e.clientX, e.clientY);
  if(paintMode.value === 'drag'){
    setCell(x,y, +brush.value);
    draw();
  }
});
canvas.addEventListener('pointerup', e=>{
  if(!painting) return; painting = false;
  if(paintMode.value === 'rect' && startCell){
    const [sx,sy] = startCell;
    const [ex,ey] = canvasToCell(e.clientX, e.clientY);
    const x0 = Math.min(sx,ex), x1 = Math.max(sx,ex);
    const y0 = Math.min(sy,ey), y1 = Math.max(sy,ey);
    const t = +brush.value;
    for(let y=y0; y<=y1; y++){
      for(let x=x0; x<=x1; x++){
        setCell(x,y,t);
      }
    }
    draw();
  }
  startCell = null;
});
canvas.addEventListener('pointerleave', ()=>{ painting=false; startCell=null; });

document.getElementById('export').addEventListener('click', ()=>{
  const state = { COLS, ROWS, grid, energy, age };
  document.getElementById('io').value = JSON.stringify(state);
});

document.getElementById('import').addEventListener('click', ()=>{
  try{
    const state = JSON.parse(document.getElementById('io').value);
    COLS = state.COLS; ROWS = state.ROWS;
    document.getElementById('cols').value = COLS;
    document.getElementById('rows').value = ROWS;
    grid = state.grid; energy = state.energy; age = state.age;
    resizeCanvas(); draw();
  }catch(err){
    alert('JSON invalide.');
  }
});

// Initialisation
resizeCanvas();
init();
draw();
</script>
</body>
</html>
